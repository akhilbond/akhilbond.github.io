---
layout: page
title: Intro to Computer Systems
permalink: /Courses/Intro_to_comp_systems/
---

## Introduction

- Textbook
  - Operating Systems Concepts(9th Edition) - Silberschatz, Galvin, and Gagne

## What is an Operating System?

#### <u>Theoretical Location of the OS</u>
```
APPLICATION (USER)
------------------
 OPERATING SYSTEM
------------------
    HARDWARE
```

- A <i><b>software layer</b></i> between the hardware and the application programs/users which provides a virtual machine interface
- A <i><b>resource manager</b></i> allows programs/users to share the hardware resources
- A <i><b>set of utilities</b></i> to simplify application development and execution

- The abstract view of a computer system

![Abstract View of the components of a Computer System](/resources/images/intro_to_comp_systems/Abstract_view_of_comp_sys.PNG)

- The users interface with the system and applications
- The operating system manages the applications and the resources the applications use
- The OS also manages the connection to the computer hardware which executes specific operations for the high level applications to work


- Benefits of an OS for application writers
  - Easy to write programs
  - Using high level abstractions instead of low level hardware details
    - Files instead of disk blocks


- Benefits of an OS for standard users
  - Easier to use the computers
    - Everyone who uses the computer do not need to be knowledgeable about computer hardware
  - Safety
    - It protects programs from each other
    - It also protects uses from each other


- Mechanisms - data structures and operations that implement an abstraction(e.g. buffer cache)
- Policies - the procedures that guides the selection of a certain course of action among alternatives(e.g. the replacement policy for the buffer cache)


- Virtual machine abstractions
  - **Process** - system abstraction - illusion of being the only job executing in the system
  - **Threads** - CPU abstraction - illusion of having a dedicated CPU
  - **Virtual Memory** - memory abstraction - illusion of having unlimited memory
  - **File System** - storage abstraction - illusion of structured, persistent storage system
  - **Messaging** - communication abstraction - illusion of reliable, ordered communication
  - **Character and block devices** - I/O abstraction - standardized I/F for devices


  - Major Issues in OS design
    - Performance - How to make it run fast?
    - Reliability - How do we keep it from crashing?
    - Persistence
    - Accounting
    - Distribution
    - Scaling


## Computer Architecture Refresher

- How a processor executes instructions
  - Fetches instructions
  - Processes data using ALU's
  - The operating system manages the CPU(processor)
  - How it executes programs
    - Fetch - using fetching unit(if multiple fetching units, then we can fetch multiple instructions at once)
    - Decode
    - Execute
    - Memory
    - Write-back

#### The Program Counter

  - Where the "next instruction" is held in the machine
  - In a special memory cell in the CPU, called the program counter (PC)

#### Registers

- Architecture Rule : Large memories are slow and smaller ones are faster
- Most programs work on only small chunks of memory in a given time period. This is called **locality**
- Most CPU's have 16-32 **general purpose registers**
- Operands and destination can be in
  - Registers only
  - Registers & 1 memory operand
  - Any combinations of registers and memory


## Process Management

  - A **process** is a program in execution. It is a unit of work within the system. Program is a **passive** entity, process is an **active** entity.
  - Typically a system has many processes, some user, some operating system running concurrently on one or more CPU's

## Memory Indirection

  - How do we access array elements efficiently if all we can do is name a cell?
    - Modify the operand to allow for fetching and operand "through" a memory location
  - This is called indirection

## Abstracting the machine

- Bare hardware provides a computation device
  - How can multiple uses share the expensive hardware between themselves?
  - Answer: Software is to give the illusion of having it all to yourself while actually sharing it with others.
- This software is the **Operating System**.

## Traps

- A way that the user can legitimately access kernel processes(such as init)
- This is also the basis of a **system call**
  - Interaction between the user and kernel is done via system calls. Each system call is providing one defined service. The user sends the service name (usually a number) and the required parameters.

## Interrupts

- Force the CPU back into system mode if the user program is off computing something
- An external event which causes the CPU to jump to a known address
- Types of Interrupts
  - Hardware - Generated by hardware devices(e.g. keystrokes for user, or data on Ethernet card)
  - Software - Generated by programs when they want to request a system call to be done
  - Traps - Generated by the CPU to indicate some error or condition, where the OS is needed
- Interrupts are commonly used for polling the system hardware(e.g. registers, input, screen, etc.)

## Input and Output

- To get user input and display output to the user
- A network card(example of an I/O device) - has 2 registers
  - A store into the "transmit" register sends the byte over wire
    - Often written as "TX"
  - A load from the "receive" register reads the last byte which was read from the wire
    - Often written as "RX"
- These registers are said to be **memory-mapped**
  - This allows the CPU to access the registers
- Reserving specific registers for devices has 2 uses
  - Allows protected access - Only the OS can access the device
  - OS can control devices and move data to/from devices using regular load and store instructions
- This is called **Programmed I/O** - having dedicated registers per device where the OS can interact with the device. The CPU polls to check the status registers to see an input or output.

## Status Registers

- A status register holds the state of the last I/O register
- The network card has 1 status register
  - To transmit, the OS writes a byte into TX and changes bit 0 of the status register to 1
  - When the card receives a byte, it puts the byte in RX and sets bit 1 of the status register back to 0

## Input driven I/O

- Polling can waste many CPU cycles -> a way to solve this is to use interrupts
  - The CPU does not have to check every time for input or Output
  - When the machine gets an input or output, the device can call an interrupt
- Interrupts have a high overhead
  - Stop the processor
  - Figure out what caused the interrupt
  - Save the user state
  - Process Request
- Interrupts take several instructions(overhead), but take less CPU cycles. Polling takes more CPU cycles, but takes less instructions(overhead)

## Direct Memory Access(DMA)

- Problem with programmed I/O : the CPU must load/store all the data into device registers
- Solution: Add more hardware to allow the device to read and write memory just like the CPU
- PIO has less overhead than DMA, however DMA is more efficient at moving data
- The DMA will cause an interrupt when the CPU is needed

#### DIfference between DMA and PIO

- In PIO the CPU polls the status register to see when it is needed, however the DMA will not need polling and cause an interrupt when it needs the CPU
